
    * The source table should have NRENs and Honeypots in a way and they 
    should provide at least threat_Type for their outputs

    * "The registration of the new source process" should be defined.

    * Should think about the database handling from code; We can use PySQLPool or SQLAlchemy
    but it could be confusing.

    * Example Commenting and Coding Style for Python Code
        ---------------------------------------------------------------------------    
        import socket
        import select
        import sys
        import os
        try:
        import threading
        except ImportError:
        import dummy_threading as threading
        
        __all__ = ["TCPServer","UDPServer","ForkingUDPServer","ForkingTCPServer",
                   "ThreadingUDPServer","ThreadingTCPServer","BaseRequestHandler",
                   "StreamRequestHandler","DatagramRequestHandler",
                   "ThreadingMixIn", "ForkingMixIn"]
        if hasattr(socket, "AF_UNIX"):
            __all__.extend(["UnixStreamServer","UnixDatagramServer",
                            "ThreadingUnixStreamServer",
                            "ThreadingUnixDatagramServer"])
        
        class BaseServer:
        
            """Base class for server classes.
            
            Methods for the caller:
            
            - __init__(server_address, RequestHandlerClass)
            - serve_forever(poll_interval=0.5)
            - shutdown()
            - handle_request() # if you do not use serve_forever()
            - fileno() -> int # for select()
            
            Methods that may be overridden:
            
            - server_bind()
            - server_activate()
            - get_request() -> request, client_address
            - handle_timeout()
            - verify_request(request, client_address)
            - server_close()
            - process_request(request, client_address)
            - shutdown_request(request)
            - close_request(request)
            - handle_error()
            
            Methods for derived classes:
            
            - finish_request(request, client_address)
           
            
            Class variables that may be overridden by derived classes or
            instances:
            
            - timeout
            - address_family
            - socket_type
            - allow_reuse_address
            
            Instance variables:
            
            - RequestHandlerClass
            - socket
            
            """ 
        ---------------------------------------------------------------------------

    * parserlardan bir ip listesi istiyoruz ve bu ip listesini create_query fonksiyonunu
    kullanarak bize yollayin diyoruz. Burda istedigimiz listenin bir formati var, ipler ara
    sinda birer bosluk olacak sekilde istiyoruz. 

    ip_list='192.140.123.2 12.1.2.3 192.168.5.4 '

    Fakat diyelimki bu listenin basinda sonunda fazladan space karakteri kaldi o zaman cakiyor.
    Bu yuzden space karakter kontrolu yapiyoruz, formati duzgun belirtmeyi unutmayalim.

    * fetch komutu vb. komutlar freebsd specific olmasin, alternatiflerini bulalim, farkli distributionlarda
    fetch parametresi yine aynimi nasil olacak bi bakalim.

    * ip olarak 0.0.0.0 gelmis kontrol etmeden eklemisiz.

    * threat tablosuna threat_name kismi NULL olarak girilen threat_type larin bastan tanimlanmis ve duyurulmus 
    olmasi lazim. Orda bi blacklist felan dusunulebilinir. Malcode iccin DNSBlackhole mesela

    * THREAT_NAME i kaldirdik bu girdiden onceki notlerin bazilari anlamsiz olabilir ona gore!

    * IPv6 icin database ' e ip6 ekleyelim.

    * Dosya actigimiz kapadigimiz ya da db baglantisi yaptigimiz kisimlar icin asagidaki statement i uygulayalim.
     
            with open("myfile.txt") as f:
                for line in f:
                   print line 

	* DB modulundeki sync commit vb fonksiyonlarda exception koymayi unutmusuz cakabilir!

	* IMPORTANT !!! : Parserlarin create_query fonksiyonuna, ip listesini hangi formatta gonderecegini belirtmemiz lazim, bununla alakali bor guide olmasi lazim.
					  ip_list : 'a b c d . .  ' birer bosluk halinda mesela
	
	* Mysql querylerini hazirlarken yazdigin statement degiskenleri icindeki butun %s leri tek tirnak icine al. '%s' seklinde.				  

    * BELKI BIRGUN SQLALCHEMY KULLANIRIZ!!!


    * >> import multiprocessing.Queue
      >> queue = Queue()
      ImportError: This platform lacks a functioning sem_open implementation, therefore, the required synchronization primitives needed will not function, 
      see issue 3770.
        
      Bu mevzu yuzunden Queue ' yu kullanamayabiliriz, multiprocessing ' de problemler olabilir o yuzden testlerde dikkat etmek lazim.
      Su link yardimci olabilir : http://www.velocityreviews.com/forums/t717985-multiprocessing-on-freebsd.html
   
    
    * IMPORTANT : parserlari subprocess.call(['python', self.sources[i].parser]) seklinde cagiriyoruz. Parserlari nobody ile calistirmamiz lazim!!!

    * nfquery cok uzun calistiginda, mysql server has gone away hatasi aliyoruz. bir de henuz daemonize etmis degiliz.
      1) Bunu test ettim fakat hata tekrar etmedi, son testlerde tekrar ortaya cikacaktir.
            -> Cozum olarak timestamp kullanilarak belli bir sureden sonra connection flush edilebilir.

    * List id ' yi nfquery.conf ' tan list type ' i okuyup list tablosundan cekiyor ve query olustururken kullaniyoruz. List id yi cekebilmemiz icin list tablosunun 
    nfquery setup ' i sirasinda default valuelarla olusturulmus olmasi gerekiyor. List tablosu hazir gelse bile, yeni list type eklemeyi etkinlestirmemiz icin bir 
    yontem bulmamiz gerekiyor. (--reconfigure gibi yapilabilir.)

    * Tum exceptlerdeki sys.exit leri gozden gecirip gereksiz olanlari silelim.                   

    * http://eric.lubow.org/2010/python/when-to-use-mysql-cursor-classes-in-python/ 


    * Bazi kodlar icin link vermek ve mail atmak lazim, mesela coloredlogger classi ve daemonizing icin.
